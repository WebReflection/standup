# 5th of February, 2026

This week focus has been around my next challenge: make *coincident* and *reflected-ffi* work not only for a *JS* to *JS* scenario, but for *Python* to *JS* and *JS* to *Python* or *Python* to *Python*.

The *combinatory logic* makes this effort more *exponential* than anticipated, so I've deiced to somehow try to split the work between *JS* to *JS* only and *Python* to *Python* only.

Currently, [reflected-ffi](https://github.com/WebReflection/reflected-ffi#readme) is a very *JS* centric approach, created after years of *Python* in *workers* dealing, effectively with *JS* things form the *main thread*, but ultimately it should allow a *Python* worker to deal with *Python* elsewhere, being this *C-Python* on the server or *Pyodide* on the browser.

The main goals for this effort is simple:

  * *Python* has a `fn(*args, **kwargs)` model *JS* misses, and because *JS* misses it, it's hard to provide the same model, through the same logic, using *JS* as "*intermediate glue*"
  * *Python* has many more "*proxy traps*" that should play well enough and preserve expectations, while *JS* proxy traps are a few, good enough for *JS*, incapable to deal with more complex operations any *Python* user would expect in the *Python* only world
  * the key is *compromise* when it comes to *Python* driving *JS*, but it makes no sense when it comes to *Python* driving *Python* itself

### MicroPython

*MicroPython*, which is the most desired and fast runtime we have on the Web thanks to its *WASM* target, lacks some primitive needed to make this *Python* to *Python* orchestration working.

This is why me and Damien (MicroPython maintainer) had to exchange a few ideas and solutions so that [new changes](https://github.com/dpgeorge/micropython/tree/webassembly-combined-patches) landed and I can finally explore the `weakref` MicroPython module that doesn't exist yet ðŸ¥³

### Performance

The *reflected-ffi* module is great, fast, and kinda battle tested, but it's inevitably convoluted.

Because to move forward with my *Python* replica of its abilities I need to narrow down complexity, I've decided to separate the *Proxy cache logic* into a different module, simply beacuse in doing so I can guarantee **100% code coverage** and have a reference for the optional *Python* implementation of the same logic. This effort landed on [npm](https://www.npmjs.com/) as [cached-proxy](https://github.com/WebReflection/cached-proxy#readme), and the idea is to remove complexity from *reflected-ffi* module and use this tiny abstraction layer behind the scene so that things will be easier to reason about.

### Architecture

Current *reflected-ffi* module, based on *JS* only assumptions, is missing so many traps available in the *Python* world I want to change the game and use those traps instead for *Python* to *Python* things.

This is why there is work on a *coincident* [branch](https://github.com/WebReflection/coincident/blob/python-server/src/python/utils.py) to have full 1:1 *Python* compatibility between different *Python* worlds/interpreters/environments.

This work is mandatory to have best DX experience, yet I need to be sure what are the proxy traps *MicroPython* understands and provides, which is a list Damien himself mentioned *not available out there anywhere* (not even in the repository) ... so I am also waiting for such list to be known, because that's the only list that could work using *MicroPython* as **the driver**.

### Maintenance

Mentoring a bit while helping [this MR to land](https://github.com/pyscript/pyscript/pull/2447) which is about improving `pyscript.web` API expectations around the `el.append(...)` utility which wouldn't understand or work as expected, to date, if a *string* or a *number* or even a *boolean* is appended as partial text content to any referenced element.

The removal of an archived, legacy related, *TOML* parser [has been finalized](https://github.com/pyscript/pyscript/pull/2442) too, so that now we don't have 2 different parsers, one ad-hoc for our config expectations, another one there since the beginning of the *PyScript* time but unmaintained in these days, making our latest release better, faster, smaller, and simpler, with the improvement that users can now use their own custom *TOML* parser, and that is now working on both *main* thread and *workers* related threads.

These and other side-topics tackled by Nicholas, allowed us to [release PyScript 2026.2.1](https://pyscript.net/releases/2026.2.1/) today, which closes so far the week to me, but more work around *reflected-ffi* and *coincident* will happen tomorrow and it will be summarized next week.
